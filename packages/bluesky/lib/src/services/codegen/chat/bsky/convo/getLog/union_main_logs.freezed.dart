// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'union_main_logs.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UConvoGetLogLogs {
  Object get data;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogs &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'UConvoGetLogLogs(data: $data)';
  }
}

/// @nodoc
class $UConvoGetLogLogsCopyWith<$Res> {
  $UConvoGetLogLogsCopyWith(
      UConvoGetLogLogs _, $Res Function(UConvoGetLogLogs) __);
}

/// Adds pattern-matching-related methods to [UConvoGetLogLogs].
extension UConvoGetLogLogsPatterns on UConvoGetLogLogs {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UConvoGetLogLogsLogBeginConvo value)? logBeginConvo,
    TResult Function(UConvoGetLogLogsLogAcceptConvo value)? logAcceptConvo,
    TResult Function(UConvoGetLogLogsLogLeaveConvo value)? logLeaveConvo,
    TResult Function(UConvoGetLogLogsLogMuteConvo value)? logMuteConvo,
    TResult Function(UConvoGetLogLogsLogUnmuteConvo value)? logUnmuteConvo,
    TResult Function(UConvoGetLogLogsLogCreateMessage value)? logCreateMessage,
    TResult Function(UConvoGetLogLogsLogDeleteMessage value)? logDeleteMessage,
    TResult Function(UConvoGetLogLogsLogReadMessage value)? logReadMessage,
    TResult Function(UConvoGetLogLogsLogAddReaction value)? logAddReaction,
    TResult Function(UConvoGetLogLogsLogRemoveReaction value)?
        logRemoveReaction,
    TResult Function(UConvoGetLogLogsUnknown value)? unknown,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case UConvoGetLogLogsLogBeginConvo() when logBeginConvo != null:
        return logBeginConvo(_that);
      case UConvoGetLogLogsLogAcceptConvo() when logAcceptConvo != null:
        return logAcceptConvo(_that);
      case UConvoGetLogLogsLogLeaveConvo() when logLeaveConvo != null:
        return logLeaveConvo(_that);
      case UConvoGetLogLogsLogMuteConvo() when logMuteConvo != null:
        return logMuteConvo(_that);
      case UConvoGetLogLogsLogUnmuteConvo() when logUnmuteConvo != null:
        return logUnmuteConvo(_that);
      case UConvoGetLogLogsLogCreateMessage() when logCreateMessage != null:
        return logCreateMessage(_that);
      case UConvoGetLogLogsLogDeleteMessage() when logDeleteMessage != null:
        return logDeleteMessage(_that);
      case UConvoGetLogLogsLogReadMessage() when logReadMessage != null:
        return logReadMessage(_that);
      case UConvoGetLogLogsLogAddReaction() when logAddReaction != null:
        return logAddReaction(_that);
      case UConvoGetLogLogsLogRemoveReaction() when logRemoveReaction != null:
        return logRemoveReaction(_that);
      case UConvoGetLogLogsUnknown() when unknown != null:
        return unknown(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UConvoGetLogLogsLogBeginConvo value)
        logBeginConvo,
    required TResult Function(UConvoGetLogLogsLogAcceptConvo value)
        logAcceptConvo,
    required TResult Function(UConvoGetLogLogsLogLeaveConvo value)
        logLeaveConvo,
    required TResult Function(UConvoGetLogLogsLogMuteConvo value) logMuteConvo,
    required TResult Function(UConvoGetLogLogsLogUnmuteConvo value)
        logUnmuteConvo,
    required TResult Function(UConvoGetLogLogsLogCreateMessage value)
        logCreateMessage,
    required TResult Function(UConvoGetLogLogsLogDeleteMessage value)
        logDeleteMessage,
    required TResult Function(UConvoGetLogLogsLogReadMessage value)
        logReadMessage,
    required TResult Function(UConvoGetLogLogsLogAddReaction value)
        logAddReaction,
    required TResult Function(UConvoGetLogLogsLogRemoveReaction value)
        logRemoveReaction,
    required TResult Function(UConvoGetLogLogsUnknown value) unknown,
  }) {
    final _that = this;
    switch (_that) {
      case UConvoGetLogLogsLogBeginConvo():
        return logBeginConvo(_that);
      case UConvoGetLogLogsLogAcceptConvo():
        return logAcceptConvo(_that);
      case UConvoGetLogLogsLogLeaveConvo():
        return logLeaveConvo(_that);
      case UConvoGetLogLogsLogMuteConvo():
        return logMuteConvo(_that);
      case UConvoGetLogLogsLogUnmuteConvo():
        return logUnmuteConvo(_that);
      case UConvoGetLogLogsLogCreateMessage():
        return logCreateMessage(_that);
      case UConvoGetLogLogsLogDeleteMessage():
        return logDeleteMessage(_that);
      case UConvoGetLogLogsLogReadMessage():
        return logReadMessage(_that);
      case UConvoGetLogLogsLogAddReaction():
        return logAddReaction(_that);
      case UConvoGetLogLogsLogRemoveReaction():
        return logRemoveReaction(_that);
      case UConvoGetLogLogsUnknown():
        return unknown(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UConvoGetLogLogsLogBeginConvo value)? logBeginConvo,
    TResult? Function(UConvoGetLogLogsLogAcceptConvo value)? logAcceptConvo,
    TResult? Function(UConvoGetLogLogsLogLeaveConvo value)? logLeaveConvo,
    TResult? Function(UConvoGetLogLogsLogMuteConvo value)? logMuteConvo,
    TResult? Function(UConvoGetLogLogsLogUnmuteConvo value)? logUnmuteConvo,
    TResult? Function(UConvoGetLogLogsLogCreateMessage value)? logCreateMessage,
    TResult? Function(UConvoGetLogLogsLogDeleteMessage value)? logDeleteMessage,
    TResult? Function(UConvoGetLogLogsLogReadMessage value)? logReadMessage,
    TResult? Function(UConvoGetLogLogsLogAddReaction value)? logAddReaction,
    TResult? Function(UConvoGetLogLogsLogRemoveReaction value)?
        logRemoveReaction,
    TResult? Function(UConvoGetLogLogsUnknown value)? unknown,
  }) {
    final _that = this;
    switch (_that) {
      case UConvoGetLogLogsLogBeginConvo() when logBeginConvo != null:
        return logBeginConvo(_that);
      case UConvoGetLogLogsLogAcceptConvo() when logAcceptConvo != null:
        return logAcceptConvo(_that);
      case UConvoGetLogLogsLogLeaveConvo() when logLeaveConvo != null:
        return logLeaveConvo(_that);
      case UConvoGetLogLogsLogMuteConvo() when logMuteConvo != null:
        return logMuteConvo(_that);
      case UConvoGetLogLogsLogUnmuteConvo() when logUnmuteConvo != null:
        return logUnmuteConvo(_that);
      case UConvoGetLogLogsLogCreateMessage() when logCreateMessage != null:
        return logCreateMessage(_that);
      case UConvoGetLogLogsLogDeleteMessage() when logDeleteMessage != null:
        return logDeleteMessage(_that);
      case UConvoGetLogLogsLogReadMessage() when logReadMessage != null:
        return logReadMessage(_that);
      case UConvoGetLogLogsLogAddReaction() when logAddReaction != null:
        return logAddReaction(_that);
      case UConvoGetLogLogsLogRemoveReaction() when logRemoveReaction != null:
        return logRemoveReaction(_that);
      case UConvoGetLogLogsUnknown() when unknown != null:
        return unknown(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LogBeginConvo data)? logBeginConvo,
    TResult Function(LogAcceptConvo data)? logAcceptConvo,
    TResult Function(LogLeaveConvo data)? logLeaveConvo,
    TResult Function(LogMuteConvo data)? logMuteConvo,
    TResult Function(LogUnmuteConvo data)? logUnmuteConvo,
    TResult Function(LogCreateMessage data)? logCreateMessage,
    TResult Function(LogDeleteMessage data)? logDeleteMessage,
    TResult Function(LogReadMessage data)? logReadMessage,
    TResult Function(LogAddReaction data)? logAddReaction,
    TResult Function(LogRemoveReaction data)? logRemoveReaction,
    TResult Function(Map<String, dynamic> data)? unknown,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case UConvoGetLogLogsLogBeginConvo() when logBeginConvo != null:
        return logBeginConvo(_that.data);
      case UConvoGetLogLogsLogAcceptConvo() when logAcceptConvo != null:
        return logAcceptConvo(_that.data);
      case UConvoGetLogLogsLogLeaveConvo() when logLeaveConvo != null:
        return logLeaveConvo(_that.data);
      case UConvoGetLogLogsLogMuteConvo() when logMuteConvo != null:
        return logMuteConvo(_that.data);
      case UConvoGetLogLogsLogUnmuteConvo() when logUnmuteConvo != null:
        return logUnmuteConvo(_that.data);
      case UConvoGetLogLogsLogCreateMessage() when logCreateMessage != null:
        return logCreateMessage(_that.data);
      case UConvoGetLogLogsLogDeleteMessage() when logDeleteMessage != null:
        return logDeleteMessage(_that.data);
      case UConvoGetLogLogsLogReadMessage() when logReadMessage != null:
        return logReadMessage(_that.data);
      case UConvoGetLogLogsLogAddReaction() when logAddReaction != null:
        return logAddReaction(_that.data);
      case UConvoGetLogLogsLogRemoveReaction() when logRemoveReaction != null:
        return logRemoveReaction(_that.data);
      case UConvoGetLogLogsUnknown() when unknown != null:
        return unknown(_that.data);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LogBeginConvo data) logBeginConvo,
    required TResult Function(LogAcceptConvo data) logAcceptConvo,
    required TResult Function(LogLeaveConvo data) logLeaveConvo,
    required TResult Function(LogMuteConvo data) logMuteConvo,
    required TResult Function(LogUnmuteConvo data) logUnmuteConvo,
    required TResult Function(LogCreateMessage data) logCreateMessage,
    required TResult Function(LogDeleteMessage data) logDeleteMessage,
    required TResult Function(LogReadMessage data) logReadMessage,
    required TResult Function(LogAddReaction data) logAddReaction,
    required TResult Function(LogRemoveReaction data) logRemoveReaction,
    required TResult Function(Map<String, dynamic> data) unknown,
  }) {
    final _that = this;
    switch (_that) {
      case UConvoGetLogLogsLogBeginConvo():
        return logBeginConvo(_that.data);
      case UConvoGetLogLogsLogAcceptConvo():
        return logAcceptConvo(_that.data);
      case UConvoGetLogLogsLogLeaveConvo():
        return logLeaveConvo(_that.data);
      case UConvoGetLogLogsLogMuteConvo():
        return logMuteConvo(_that.data);
      case UConvoGetLogLogsLogUnmuteConvo():
        return logUnmuteConvo(_that.data);
      case UConvoGetLogLogsLogCreateMessage():
        return logCreateMessage(_that.data);
      case UConvoGetLogLogsLogDeleteMessage():
        return logDeleteMessage(_that.data);
      case UConvoGetLogLogsLogReadMessage():
        return logReadMessage(_that.data);
      case UConvoGetLogLogsLogAddReaction():
        return logAddReaction(_that.data);
      case UConvoGetLogLogsLogRemoveReaction():
        return logRemoveReaction(_that.data);
      case UConvoGetLogLogsUnknown():
        return unknown(_that.data);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LogBeginConvo data)? logBeginConvo,
    TResult? Function(LogAcceptConvo data)? logAcceptConvo,
    TResult? Function(LogLeaveConvo data)? logLeaveConvo,
    TResult? Function(LogMuteConvo data)? logMuteConvo,
    TResult? Function(LogUnmuteConvo data)? logUnmuteConvo,
    TResult? Function(LogCreateMessage data)? logCreateMessage,
    TResult? Function(LogDeleteMessage data)? logDeleteMessage,
    TResult? Function(LogReadMessage data)? logReadMessage,
    TResult? Function(LogAddReaction data)? logAddReaction,
    TResult? Function(LogRemoveReaction data)? logRemoveReaction,
    TResult? Function(Map<String, dynamic> data)? unknown,
  }) {
    final _that = this;
    switch (_that) {
      case UConvoGetLogLogsLogBeginConvo() when logBeginConvo != null:
        return logBeginConvo(_that.data);
      case UConvoGetLogLogsLogAcceptConvo() when logAcceptConvo != null:
        return logAcceptConvo(_that.data);
      case UConvoGetLogLogsLogLeaveConvo() when logLeaveConvo != null:
        return logLeaveConvo(_that.data);
      case UConvoGetLogLogsLogMuteConvo() when logMuteConvo != null:
        return logMuteConvo(_that.data);
      case UConvoGetLogLogsLogUnmuteConvo() when logUnmuteConvo != null:
        return logUnmuteConvo(_that.data);
      case UConvoGetLogLogsLogCreateMessage() when logCreateMessage != null:
        return logCreateMessage(_that.data);
      case UConvoGetLogLogsLogDeleteMessage() when logDeleteMessage != null:
        return logDeleteMessage(_that.data);
      case UConvoGetLogLogsLogReadMessage() when logReadMessage != null:
        return logReadMessage(_that.data);
      case UConvoGetLogLogsLogAddReaction() when logAddReaction != null:
        return logAddReaction(_that.data);
      case UConvoGetLogLogsLogRemoveReaction() when logRemoveReaction != null:
        return logRemoveReaction(_that.data);
      case UConvoGetLogLogsUnknown() when unknown != null:
        return unknown(_that.data);
      case _:
        return null;
    }
  }
}

/// @nodoc

class UConvoGetLogLogsLogBeginConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogBeginConvo({required this.data}) : super._();

  @override
  final LogBeginConvo data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogBeginConvoCopyWith<UConvoGetLogLogsLogBeginConvo>
      get copyWith => _$UConvoGetLogLogsLogBeginConvoCopyWithImpl<
          UConvoGetLogLogsLogBeginConvo>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogBeginConvo &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logBeginConvo(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogBeginConvoCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogBeginConvoCopyWith(
          UConvoGetLogLogsLogBeginConvo value,
          $Res Function(UConvoGetLogLogsLogBeginConvo) _then) =
      _$UConvoGetLogLogsLogBeginConvoCopyWithImpl;
  @useResult
  $Res call({LogBeginConvo data});

  $LogBeginConvoCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogBeginConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogBeginConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogBeginConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogBeginConvo _self;
  final $Res Function(UConvoGetLogLogsLogBeginConvo) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogBeginConvo(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogBeginConvo,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogBeginConvoCopyWith<$Res> get data {
    return $LogBeginConvoCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogAcceptConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogAcceptConvo({required this.data}) : super._();

  @override
  final LogAcceptConvo data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogAcceptConvoCopyWith<UConvoGetLogLogsLogAcceptConvo>
      get copyWith => _$UConvoGetLogLogsLogAcceptConvoCopyWithImpl<
          UConvoGetLogLogsLogAcceptConvo>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogAcceptConvo &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logAcceptConvo(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogAcceptConvoCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogAcceptConvoCopyWith(
          UConvoGetLogLogsLogAcceptConvo value,
          $Res Function(UConvoGetLogLogsLogAcceptConvo) _then) =
      _$UConvoGetLogLogsLogAcceptConvoCopyWithImpl;
  @useResult
  $Res call({LogAcceptConvo data});

  $LogAcceptConvoCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogAcceptConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogAcceptConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogAcceptConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogAcceptConvo _self;
  final $Res Function(UConvoGetLogLogsLogAcceptConvo) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogAcceptConvo(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogAcceptConvo,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogAcceptConvoCopyWith<$Res> get data {
    return $LogAcceptConvoCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogLeaveConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogLeaveConvo({required this.data}) : super._();

  @override
  final LogLeaveConvo data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogLeaveConvoCopyWith<UConvoGetLogLogsLogLeaveConvo>
      get copyWith => _$UConvoGetLogLogsLogLeaveConvoCopyWithImpl<
          UConvoGetLogLogsLogLeaveConvo>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogLeaveConvo &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logLeaveConvo(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogLeaveConvoCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogLeaveConvoCopyWith(
          UConvoGetLogLogsLogLeaveConvo value,
          $Res Function(UConvoGetLogLogsLogLeaveConvo) _then) =
      _$UConvoGetLogLogsLogLeaveConvoCopyWithImpl;
  @useResult
  $Res call({LogLeaveConvo data});

  $LogLeaveConvoCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogLeaveConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogLeaveConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogLeaveConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogLeaveConvo _self;
  final $Res Function(UConvoGetLogLogsLogLeaveConvo) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogLeaveConvo(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogLeaveConvo,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogLeaveConvoCopyWith<$Res> get data {
    return $LogLeaveConvoCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogMuteConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogMuteConvo({required this.data}) : super._();

  @override
  final LogMuteConvo data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogMuteConvoCopyWith<UConvoGetLogLogsLogMuteConvo>
      get copyWith => _$UConvoGetLogLogsLogMuteConvoCopyWithImpl<
          UConvoGetLogLogsLogMuteConvo>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogMuteConvo &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logMuteConvo(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogMuteConvoCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogMuteConvoCopyWith(
          UConvoGetLogLogsLogMuteConvo value,
          $Res Function(UConvoGetLogLogsLogMuteConvo) _then) =
      _$UConvoGetLogLogsLogMuteConvoCopyWithImpl;
  @useResult
  $Res call({LogMuteConvo data});

  $LogMuteConvoCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogMuteConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogMuteConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogMuteConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogMuteConvo _self;
  final $Res Function(UConvoGetLogLogsLogMuteConvo) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogMuteConvo(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogMuteConvo,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogMuteConvoCopyWith<$Res> get data {
    return $LogMuteConvoCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogUnmuteConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogUnmuteConvo({required this.data}) : super._();

  @override
  final LogUnmuteConvo data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogUnmuteConvoCopyWith<UConvoGetLogLogsLogUnmuteConvo>
      get copyWith => _$UConvoGetLogLogsLogUnmuteConvoCopyWithImpl<
          UConvoGetLogLogsLogUnmuteConvo>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogUnmuteConvo &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logUnmuteConvo(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogUnmuteConvoCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogUnmuteConvoCopyWith(
          UConvoGetLogLogsLogUnmuteConvo value,
          $Res Function(UConvoGetLogLogsLogUnmuteConvo) _then) =
      _$UConvoGetLogLogsLogUnmuteConvoCopyWithImpl;
  @useResult
  $Res call({LogUnmuteConvo data});

  $LogUnmuteConvoCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogUnmuteConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogUnmuteConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogUnmuteConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogUnmuteConvo _self;
  final $Res Function(UConvoGetLogLogsLogUnmuteConvo) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogUnmuteConvo(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogUnmuteConvo,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogUnmuteConvoCopyWith<$Res> get data {
    return $LogUnmuteConvoCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogCreateMessage extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogCreateMessage({required this.data}) : super._();

  @override
  final LogCreateMessage data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogCreateMessageCopyWith<UConvoGetLogLogsLogCreateMessage>
      get copyWith => _$UConvoGetLogLogsLogCreateMessageCopyWithImpl<
          UConvoGetLogLogsLogCreateMessage>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogCreateMessage &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logCreateMessage(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogCreateMessageCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogCreateMessageCopyWith(
          UConvoGetLogLogsLogCreateMessage value,
          $Res Function(UConvoGetLogLogsLogCreateMessage) _then) =
      _$UConvoGetLogLogsLogCreateMessageCopyWithImpl;
  @useResult
  $Res call({LogCreateMessage data});

  $LogCreateMessageCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogCreateMessageCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogCreateMessageCopyWith<$Res> {
  _$UConvoGetLogLogsLogCreateMessageCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogCreateMessage _self;
  final $Res Function(UConvoGetLogLogsLogCreateMessage) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogCreateMessage(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogCreateMessage,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogCreateMessageCopyWith<$Res> get data {
    return $LogCreateMessageCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogDeleteMessage extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogDeleteMessage({required this.data}) : super._();

  @override
  final LogDeleteMessage data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogDeleteMessageCopyWith<UConvoGetLogLogsLogDeleteMessage>
      get copyWith => _$UConvoGetLogLogsLogDeleteMessageCopyWithImpl<
          UConvoGetLogLogsLogDeleteMessage>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogDeleteMessage &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logDeleteMessage(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogDeleteMessageCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogDeleteMessageCopyWith(
          UConvoGetLogLogsLogDeleteMessage value,
          $Res Function(UConvoGetLogLogsLogDeleteMessage) _then) =
      _$UConvoGetLogLogsLogDeleteMessageCopyWithImpl;
  @useResult
  $Res call({LogDeleteMessage data});

  $LogDeleteMessageCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogDeleteMessageCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogDeleteMessageCopyWith<$Res> {
  _$UConvoGetLogLogsLogDeleteMessageCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogDeleteMessage _self;
  final $Res Function(UConvoGetLogLogsLogDeleteMessage) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogDeleteMessage(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogDeleteMessage,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogDeleteMessageCopyWith<$Res> get data {
    return $LogDeleteMessageCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogReadMessage extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogReadMessage({required this.data}) : super._();

  @override
  final LogReadMessage data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogReadMessageCopyWith<UConvoGetLogLogsLogReadMessage>
      get copyWith => _$UConvoGetLogLogsLogReadMessageCopyWithImpl<
          UConvoGetLogLogsLogReadMessage>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogReadMessage &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logReadMessage(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogReadMessageCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogReadMessageCopyWith(
          UConvoGetLogLogsLogReadMessage value,
          $Res Function(UConvoGetLogLogsLogReadMessage) _then) =
      _$UConvoGetLogLogsLogReadMessageCopyWithImpl;
  @useResult
  $Res call({LogReadMessage data});

  $LogReadMessageCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogReadMessageCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogReadMessageCopyWith<$Res> {
  _$UConvoGetLogLogsLogReadMessageCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogReadMessage _self;
  final $Res Function(UConvoGetLogLogsLogReadMessage) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogReadMessage(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogReadMessage,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogReadMessageCopyWith<$Res> get data {
    return $LogReadMessageCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogAddReaction extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogAddReaction({required this.data}) : super._();

  @override
  final LogAddReaction data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogAddReactionCopyWith<UConvoGetLogLogsLogAddReaction>
      get copyWith => _$UConvoGetLogLogsLogAddReactionCopyWithImpl<
          UConvoGetLogLogsLogAddReaction>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogAddReaction &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logAddReaction(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogAddReactionCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogAddReactionCopyWith(
          UConvoGetLogLogsLogAddReaction value,
          $Res Function(UConvoGetLogLogsLogAddReaction) _then) =
      _$UConvoGetLogLogsLogAddReactionCopyWithImpl;
  @useResult
  $Res call({LogAddReaction data});

  $LogAddReactionCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogAddReactionCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogAddReactionCopyWith<$Res> {
  _$UConvoGetLogLogsLogAddReactionCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogAddReaction _self;
  final $Res Function(UConvoGetLogLogsLogAddReaction) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogAddReaction(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogAddReaction,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogAddReactionCopyWith<$Res> get data {
    return $LogAddReactionCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsLogRemoveReaction extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogRemoveReaction({required this.data}) : super._();

  @override
  final LogRemoveReaction data;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsLogRemoveReactionCopyWith<UConvoGetLogLogsLogRemoveReaction>
      get copyWith => _$UConvoGetLogLogsLogRemoveReactionCopyWithImpl<
          UConvoGetLogLogsLogRemoveReaction>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsLogRemoveReaction &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UConvoGetLogLogs.logRemoveReaction(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogRemoveReactionCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogRemoveReactionCopyWith(
          UConvoGetLogLogsLogRemoveReaction value,
          $Res Function(UConvoGetLogLogsLogRemoveReaction) _then) =
      _$UConvoGetLogLogsLogRemoveReactionCopyWithImpl;
  @useResult
  $Res call({LogRemoveReaction data});

  $LogRemoveReactionCopyWith<$Res> get data;
}

/// @nodoc
class _$UConvoGetLogLogsLogRemoveReactionCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogRemoveReactionCopyWith<$Res> {
  _$UConvoGetLogLogsLogRemoveReactionCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogRemoveReaction _self;
  final $Res Function(UConvoGetLogLogsLogRemoveReaction) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsLogRemoveReaction(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LogRemoveReaction,
    ));
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogRemoveReactionCopyWith<$Res> get data {
    return $LogRemoveReactionCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UConvoGetLogLogsUnknown extends UConvoGetLogLogs {
  const UConvoGetLogLogsUnknown({required final Map<String, dynamic> data})
      : _data = data,
        super._();

  final Map<String, dynamic> _data;
  @override
  Map<String, dynamic> get data {
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_data);
  }

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UConvoGetLogLogsUnknownCopyWith<UConvoGetLogLogsUnknown> get copyWith =>
      _$UConvoGetLogLogsUnknownCopyWithImpl<UConvoGetLogLogsUnknown>(
          this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UConvoGetLogLogsUnknown &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));

  @override
  String toString() {
    return 'UConvoGetLogLogs.unknown(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UConvoGetLogLogsUnknownCopyWith<$Res>
    implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsUnknownCopyWith(UConvoGetLogLogsUnknown value,
          $Res Function(UConvoGetLogLogsUnknown) _then) =
      _$UConvoGetLogLogsUnknownCopyWithImpl;
  @useResult
  $Res call({Map<String, dynamic> data});
}

/// @nodoc
class _$UConvoGetLogLogsUnknownCopyWithImpl<$Res>
    implements $UConvoGetLogLogsUnknownCopyWith<$Res> {
  _$UConvoGetLogLogsUnknownCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsUnknown _self;
  final $Res Function(UConvoGetLogLogsUnknown) _then;

  /// Create a copy of UConvoGetLogLogs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UConvoGetLogLogsUnknown(
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

// dart format on
