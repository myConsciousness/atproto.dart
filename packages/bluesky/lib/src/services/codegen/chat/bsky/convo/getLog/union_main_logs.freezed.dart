// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'union_main_logs.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$UConvoGetLogLogs {

 Object get data;



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogs&&const DeepCollectionEquality().equals(other.data, data));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data));

@override
String toString() {
  return 'UConvoGetLogLogs(data: $data)';
}


}

/// @nodoc
class $UConvoGetLogLogsCopyWith<$Res>  {
$UConvoGetLogLogsCopyWith(UConvoGetLogLogs _, $Res Function(UConvoGetLogLogs) __);
}


/// Adds pattern-matching-related methods to [UConvoGetLogLogs].
extension UConvoGetLogLogsPatterns on UConvoGetLogLogs {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( UConvoGetLogLogsLogBeginConvo value)?  logBeginConvo,TResult Function( UConvoGetLogLogsLogAcceptConvo value)?  logAcceptConvo,TResult Function( UConvoGetLogLogsLogLeaveConvo value)?  logLeaveConvo,TResult Function( UConvoGetLogLogsLogMuteConvo value)?  logMuteConvo,TResult Function( UConvoGetLogLogsLogUnmuteConvo value)?  logUnmuteConvo,TResult Function( UConvoGetLogLogsLogCreateMessage value)?  logCreateMessage,TResult Function( UConvoGetLogLogsLogDeleteMessage value)?  logDeleteMessage,TResult Function( UConvoGetLogLogsLogReadMessage value)?  logReadMessage,TResult Function( UConvoGetLogLogsLogAddReaction value)?  logAddReaction,TResult Function( UConvoGetLogLogsLogRemoveReaction value)?  logRemoveReaction,TResult Function( UConvoGetLogLogsUnknown value)?  unknown,required TResult orElse(),}){
final _that = this;
switch (_that) {
case UConvoGetLogLogsLogBeginConvo() when logBeginConvo != null:
return logBeginConvo(_that);case UConvoGetLogLogsLogAcceptConvo() when logAcceptConvo != null:
return logAcceptConvo(_that);case UConvoGetLogLogsLogLeaveConvo() when logLeaveConvo != null:
return logLeaveConvo(_that);case UConvoGetLogLogsLogMuteConvo() when logMuteConvo != null:
return logMuteConvo(_that);case UConvoGetLogLogsLogUnmuteConvo() when logUnmuteConvo != null:
return logUnmuteConvo(_that);case UConvoGetLogLogsLogCreateMessage() when logCreateMessage != null:
return logCreateMessage(_that);case UConvoGetLogLogsLogDeleteMessage() when logDeleteMessage != null:
return logDeleteMessage(_that);case UConvoGetLogLogsLogReadMessage() when logReadMessage != null:
return logReadMessage(_that);case UConvoGetLogLogsLogAddReaction() when logAddReaction != null:
return logAddReaction(_that);case UConvoGetLogLogsLogRemoveReaction() when logRemoveReaction != null:
return logRemoveReaction(_that);case UConvoGetLogLogsUnknown() when unknown != null:
return unknown(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( UConvoGetLogLogsLogBeginConvo value)  logBeginConvo,required TResult Function( UConvoGetLogLogsLogAcceptConvo value)  logAcceptConvo,required TResult Function( UConvoGetLogLogsLogLeaveConvo value)  logLeaveConvo,required TResult Function( UConvoGetLogLogsLogMuteConvo value)  logMuteConvo,required TResult Function( UConvoGetLogLogsLogUnmuteConvo value)  logUnmuteConvo,required TResult Function( UConvoGetLogLogsLogCreateMessage value)  logCreateMessage,required TResult Function( UConvoGetLogLogsLogDeleteMessage value)  logDeleteMessage,required TResult Function( UConvoGetLogLogsLogReadMessage value)  logReadMessage,required TResult Function( UConvoGetLogLogsLogAddReaction value)  logAddReaction,required TResult Function( UConvoGetLogLogsLogRemoveReaction value)  logRemoveReaction,required TResult Function( UConvoGetLogLogsUnknown value)  unknown,}){
final _that = this;
switch (_that) {
case UConvoGetLogLogsLogBeginConvo():
return logBeginConvo(_that);case UConvoGetLogLogsLogAcceptConvo():
return logAcceptConvo(_that);case UConvoGetLogLogsLogLeaveConvo():
return logLeaveConvo(_that);case UConvoGetLogLogsLogMuteConvo():
return logMuteConvo(_that);case UConvoGetLogLogsLogUnmuteConvo():
return logUnmuteConvo(_that);case UConvoGetLogLogsLogCreateMessage():
return logCreateMessage(_that);case UConvoGetLogLogsLogDeleteMessage():
return logDeleteMessage(_that);case UConvoGetLogLogsLogReadMessage():
return logReadMessage(_that);case UConvoGetLogLogsLogAddReaction():
return logAddReaction(_that);case UConvoGetLogLogsLogRemoveReaction():
return logRemoveReaction(_that);case UConvoGetLogLogsUnknown():
return unknown(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( UConvoGetLogLogsLogBeginConvo value)?  logBeginConvo,TResult? Function( UConvoGetLogLogsLogAcceptConvo value)?  logAcceptConvo,TResult? Function( UConvoGetLogLogsLogLeaveConvo value)?  logLeaveConvo,TResult? Function( UConvoGetLogLogsLogMuteConvo value)?  logMuteConvo,TResult? Function( UConvoGetLogLogsLogUnmuteConvo value)?  logUnmuteConvo,TResult? Function( UConvoGetLogLogsLogCreateMessage value)?  logCreateMessage,TResult? Function( UConvoGetLogLogsLogDeleteMessage value)?  logDeleteMessage,TResult? Function( UConvoGetLogLogsLogReadMessage value)?  logReadMessage,TResult? Function( UConvoGetLogLogsLogAddReaction value)?  logAddReaction,TResult? Function( UConvoGetLogLogsLogRemoveReaction value)?  logRemoveReaction,TResult? Function( UConvoGetLogLogsUnknown value)?  unknown,}){
final _that = this;
switch (_that) {
case UConvoGetLogLogsLogBeginConvo() when logBeginConvo != null:
return logBeginConvo(_that);case UConvoGetLogLogsLogAcceptConvo() when logAcceptConvo != null:
return logAcceptConvo(_that);case UConvoGetLogLogsLogLeaveConvo() when logLeaveConvo != null:
return logLeaveConvo(_that);case UConvoGetLogLogsLogMuteConvo() when logMuteConvo != null:
return logMuteConvo(_that);case UConvoGetLogLogsLogUnmuteConvo() when logUnmuteConvo != null:
return logUnmuteConvo(_that);case UConvoGetLogLogsLogCreateMessage() when logCreateMessage != null:
return logCreateMessage(_that);case UConvoGetLogLogsLogDeleteMessage() when logDeleteMessage != null:
return logDeleteMessage(_that);case UConvoGetLogLogsLogReadMessage() when logReadMessage != null:
return logReadMessage(_that);case UConvoGetLogLogsLogAddReaction() when logAddReaction != null:
return logAddReaction(_that);case UConvoGetLogLogsLogRemoveReaction() when logRemoveReaction != null:
return logRemoveReaction(_that);case UConvoGetLogLogsUnknown() when unknown != null:
return unknown(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function( LogBeginConvo data)?  logBeginConvo,TResult Function( LogAcceptConvo data)?  logAcceptConvo,TResult Function( LogLeaveConvo data)?  logLeaveConvo,TResult Function( LogMuteConvo data)?  logMuteConvo,TResult Function( LogUnmuteConvo data)?  logUnmuteConvo,TResult Function( LogCreateMessage data)?  logCreateMessage,TResult Function( LogDeleteMessage data)?  logDeleteMessage,TResult Function( LogReadMessage data)?  logReadMessage,TResult Function( LogAddReaction data)?  logAddReaction,TResult Function( LogRemoveReaction data)?  logRemoveReaction,TResult Function( Map<String, dynamic> data)?  unknown,required TResult orElse(),}) {final _that = this;
switch (_that) {
case UConvoGetLogLogsLogBeginConvo() when logBeginConvo != null:
return logBeginConvo(_that.data);case UConvoGetLogLogsLogAcceptConvo() when logAcceptConvo != null:
return logAcceptConvo(_that.data);case UConvoGetLogLogsLogLeaveConvo() when logLeaveConvo != null:
return logLeaveConvo(_that.data);case UConvoGetLogLogsLogMuteConvo() when logMuteConvo != null:
return logMuteConvo(_that.data);case UConvoGetLogLogsLogUnmuteConvo() when logUnmuteConvo != null:
return logUnmuteConvo(_that.data);case UConvoGetLogLogsLogCreateMessage() when logCreateMessage != null:
return logCreateMessage(_that.data);case UConvoGetLogLogsLogDeleteMessage() when logDeleteMessage != null:
return logDeleteMessage(_that.data);case UConvoGetLogLogsLogReadMessage() when logReadMessage != null:
return logReadMessage(_that.data);case UConvoGetLogLogsLogAddReaction() when logAddReaction != null:
return logAddReaction(_that.data);case UConvoGetLogLogsLogRemoveReaction() when logRemoveReaction != null:
return logRemoveReaction(_that.data);case UConvoGetLogLogsUnknown() when unknown != null:
return unknown(_that.data);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function( LogBeginConvo data)  logBeginConvo,required TResult Function( LogAcceptConvo data)  logAcceptConvo,required TResult Function( LogLeaveConvo data)  logLeaveConvo,required TResult Function( LogMuteConvo data)  logMuteConvo,required TResult Function( LogUnmuteConvo data)  logUnmuteConvo,required TResult Function( LogCreateMessage data)  logCreateMessage,required TResult Function( LogDeleteMessage data)  logDeleteMessage,required TResult Function( LogReadMessage data)  logReadMessage,required TResult Function( LogAddReaction data)  logAddReaction,required TResult Function( LogRemoveReaction data)  logRemoveReaction,required TResult Function( Map<String, dynamic> data)  unknown,}) {final _that = this;
switch (_that) {
case UConvoGetLogLogsLogBeginConvo():
return logBeginConvo(_that.data);case UConvoGetLogLogsLogAcceptConvo():
return logAcceptConvo(_that.data);case UConvoGetLogLogsLogLeaveConvo():
return logLeaveConvo(_that.data);case UConvoGetLogLogsLogMuteConvo():
return logMuteConvo(_that.data);case UConvoGetLogLogsLogUnmuteConvo():
return logUnmuteConvo(_that.data);case UConvoGetLogLogsLogCreateMessage():
return logCreateMessage(_that.data);case UConvoGetLogLogsLogDeleteMessage():
return logDeleteMessage(_that.data);case UConvoGetLogLogsLogReadMessage():
return logReadMessage(_that.data);case UConvoGetLogLogsLogAddReaction():
return logAddReaction(_that.data);case UConvoGetLogLogsLogRemoveReaction():
return logRemoveReaction(_that.data);case UConvoGetLogLogsUnknown():
return unknown(_that.data);}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function( LogBeginConvo data)?  logBeginConvo,TResult? Function( LogAcceptConvo data)?  logAcceptConvo,TResult? Function( LogLeaveConvo data)?  logLeaveConvo,TResult? Function( LogMuteConvo data)?  logMuteConvo,TResult? Function( LogUnmuteConvo data)?  logUnmuteConvo,TResult? Function( LogCreateMessage data)?  logCreateMessage,TResult? Function( LogDeleteMessage data)?  logDeleteMessage,TResult? Function( LogReadMessage data)?  logReadMessage,TResult? Function( LogAddReaction data)?  logAddReaction,TResult? Function( LogRemoveReaction data)?  logRemoveReaction,TResult? Function( Map<String, dynamic> data)?  unknown,}) {final _that = this;
switch (_that) {
case UConvoGetLogLogsLogBeginConvo() when logBeginConvo != null:
return logBeginConvo(_that.data);case UConvoGetLogLogsLogAcceptConvo() when logAcceptConvo != null:
return logAcceptConvo(_that.data);case UConvoGetLogLogsLogLeaveConvo() when logLeaveConvo != null:
return logLeaveConvo(_that.data);case UConvoGetLogLogsLogMuteConvo() when logMuteConvo != null:
return logMuteConvo(_that.data);case UConvoGetLogLogsLogUnmuteConvo() when logUnmuteConvo != null:
return logUnmuteConvo(_that.data);case UConvoGetLogLogsLogCreateMessage() when logCreateMessage != null:
return logCreateMessage(_that.data);case UConvoGetLogLogsLogDeleteMessage() when logDeleteMessage != null:
return logDeleteMessage(_that.data);case UConvoGetLogLogsLogReadMessage() when logReadMessage != null:
return logReadMessage(_that.data);case UConvoGetLogLogsLogAddReaction() when logAddReaction != null:
return logAddReaction(_that.data);case UConvoGetLogLogsLogRemoveReaction() when logRemoveReaction != null:
return logRemoveReaction(_that.data);case UConvoGetLogLogsUnknown() when unknown != null:
return unknown(_that.data);case _:
  return null;

}
}

}

/// @nodoc


class UConvoGetLogLogsLogBeginConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogBeginConvo({required this.data}): super._();
  

@override final  LogBeginConvo data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogBeginConvoCopyWith<UConvoGetLogLogsLogBeginConvo> get copyWith => _$UConvoGetLogLogsLogBeginConvoCopyWithImpl<UConvoGetLogLogsLogBeginConvo>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogBeginConvo&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logBeginConvo(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogBeginConvoCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogBeginConvoCopyWith(UConvoGetLogLogsLogBeginConvo value, $Res Function(UConvoGetLogLogsLogBeginConvo) _then) = _$UConvoGetLogLogsLogBeginConvoCopyWithImpl;
@useResult
$Res call({
 LogBeginConvo data
});


$LogBeginConvoCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogBeginConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogBeginConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogBeginConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogBeginConvo _self;
  final $Res Function(UConvoGetLogLogsLogBeginConvo) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogBeginConvo(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogBeginConvo,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogBeginConvoCopyWith<$Res> get data {
  
  return $LogBeginConvoCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogAcceptConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogAcceptConvo({required this.data}): super._();
  

@override final  LogAcceptConvo data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogAcceptConvoCopyWith<UConvoGetLogLogsLogAcceptConvo> get copyWith => _$UConvoGetLogLogsLogAcceptConvoCopyWithImpl<UConvoGetLogLogsLogAcceptConvo>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogAcceptConvo&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logAcceptConvo(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogAcceptConvoCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogAcceptConvoCopyWith(UConvoGetLogLogsLogAcceptConvo value, $Res Function(UConvoGetLogLogsLogAcceptConvo) _then) = _$UConvoGetLogLogsLogAcceptConvoCopyWithImpl;
@useResult
$Res call({
 LogAcceptConvo data
});


$LogAcceptConvoCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogAcceptConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogAcceptConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogAcceptConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogAcceptConvo _self;
  final $Res Function(UConvoGetLogLogsLogAcceptConvo) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogAcceptConvo(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogAcceptConvo,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogAcceptConvoCopyWith<$Res> get data {
  
  return $LogAcceptConvoCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogLeaveConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogLeaveConvo({required this.data}): super._();
  

@override final  LogLeaveConvo data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogLeaveConvoCopyWith<UConvoGetLogLogsLogLeaveConvo> get copyWith => _$UConvoGetLogLogsLogLeaveConvoCopyWithImpl<UConvoGetLogLogsLogLeaveConvo>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogLeaveConvo&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logLeaveConvo(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogLeaveConvoCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogLeaveConvoCopyWith(UConvoGetLogLogsLogLeaveConvo value, $Res Function(UConvoGetLogLogsLogLeaveConvo) _then) = _$UConvoGetLogLogsLogLeaveConvoCopyWithImpl;
@useResult
$Res call({
 LogLeaveConvo data
});


$LogLeaveConvoCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogLeaveConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogLeaveConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogLeaveConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogLeaveConvo _self;
  final $Res Function(UConvoGetLogLogsLogLeaveConvo) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogLeaveConvo(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogLeaveConvo,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogLeaveConvoCopyWith<$Res> get data {
  
  return $LogLeaveConvoCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogMuteConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogMuteConvo({required this.data}): super._();
  

@override final  LogMuteConvo data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogMuteConvoCopyWith<UConvoGetLogLogsLogMuteConvo> get copyWith => _$UConvoGetLogLogsLogMuteConvoCopyWithImpl<UConvoGetLogLogsLogMuteConvo>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogMuteConvo&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logMuteConvo(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogMuteConvoCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogMuteConvoCopyWith(UConvoGetLogLogsLogMuteConvo value, $Res Function(UConvoGetLogLogsLogMuteConvo) _then) = _$UConvoGetLogLogsLogMuteConvoCopyWithImpl;
@useResult
$Res call({
 LogMuteConvo data
});


$LogMuteConvoCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogMuteConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogMuteConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogMuteConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogMuteConvo _self;
  final $Res Function(UConvoGetLogLogsLogMuteConvo) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogMuteConvo(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogMuteConvo,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogMuteConvoCopyWith<$Res> get data {
  
  return $LogMuteConvoCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogUnmuteConvo extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogUnmuteConvo({required this.data}): super._();
  

@override final  LogUnmuteConvo data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogUnmuteConvoCopyWith<UConvoGetLogLogsLogUnmuteConvo> get copyWith => _$UConvoGetLogLogsLogUnmuteConvoCopyWithImpl<UConvoGetLogLogsLogUnmuteConvo>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogUnmuteConvo&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logUnmuteConvo(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogUnmuteConvoCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogUnmuteConvoCopyWith(UConvoGetLogLogsLogUnmuteConvo value, $Res Function(UConvoGetLogLogsLogUnmuteConvo) _then) = _$UConvoGetLogLogsLogUnmuteConvoCopyWithImpl;
@useResult
$Res call({
 LogUnmuteConvo data
});


$LogUnmuteConvoCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogUnmuteConvoCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogUnmuteConvoCopyWith<$Res> {
  _$UConvoGetLogLogsLogUnmuteConvoCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogUnmuteConvo _self;
  final $Res Function(UConvoGetLogLogsLogUnmuteConvo) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogUnmuteConvo(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogUnmuteConvo,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogUnmuteConvoCopyWith<$Res> get data {
  
  return $LogUnmuteConvoCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogCreateMessage extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogCreateMessage({required this.data}): super._();
  

@override final  LogCreateMessage data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogCreateMessageCopyWith<UConvoGetLogLogsLogCreateMessage> get copyWith => _$UConvoGetLogLogsLogCreateMessageCopyWithImpl<UConvoGetLogLogsLogCreateMessage>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogCreateMessage&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logCreateMessage(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogCreateMessageCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogCreateMessageCopyWith(UConvoGetLogLogsLogCreateMessage value, $Res Function(UConvoGetLogLogsLogCreateMessage) _then) = _$UConvoGetLogLogsLogCreateMessageCopyWithImpl;
@useResult
$Res call({
 LogCreateMessage data
});


$LogCreateMessageCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogCreateMessageCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogCreateMessageCopyWith<$Res> {
  _$UConvoGetLogLogsLogCreateMessageCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogCreateMessage _self;
  final $Res Function(UConvoGetLogLogsLogCreateMessage) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogCreateMessage(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogCreateMessage,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogCreateMessageCopyWith<$Res> get data {
  
  return $LogCreateMessageCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogDeleteMessage extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogDeleteMessage({required this.data}): super._();
  

@override final  LogDeleteMessage data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogDeleteMessageCopyWith<UConvoGetLogLogsLogDeleteMessage> get copyWith => _$UConvoGetLogLogsLogDeleteMessageCopyWithImpl<UConvoGetLogLogsLogDeleteMessage>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogDeleteMessage&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logDeleteMessage(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogDeleteMessageCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogDeleteMessageCopyWith(UConvoGetLogLogsLogDeleteMessage value, $Res Function(UConvoGetLogLogsLogDeleteMessage) _then) = _$UConvoGetLogLogsLogDeleteMessageCopyWithImpl;
@useResult
$Res call({
 LogDeleteMessage data
});


$LogDeleteMessageCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogDeleteMessageCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogDeleteMessageCopyWith<$Res> {
  _$UConvoGetLogLogsLogDeleteMessageCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogDeleteMessage _self;
  final $Res Function(UConvoGetLogLogsLogDeleteMessage) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogDeleteMessage(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogDeleteMessage,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogDeleteMessageCopyWith<$Res> get data {
  
  return $LogDeleteMessageCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogReadMessage extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogReadMessage({required this.data}): super._();
  

@override final  LogReadMessage data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogReadMessageCopyWith<UConvoGetLogLogsLogReadMessage> get copyWith => _$UConvoGetLogLogsLogReadMessageCopyWithImpl<UConvoGetLogLogsLogReadMessage>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogReadMessage&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logReadMessage(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogReadMessageCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogReadMessageCopyWith(UConvoGetLogLogsLogReadMessage value, $Res Function(UConvoGetLogLogsLogReadMessage) _then) = _$UConvoGetLogLogsLogReadMessageCopyWithImpl;
@useResult
$Res call({
 LogReadMessage data
});


$LogReadMessageCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogReadMessageCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogReadMessageCopyWith<$Res> {
  _$UConvoGetLogLogsLogReadMessageCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogReadMessage _self;
  final $Res Function(UConvoGetLogLogsLogReadMessage) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogReadMessage(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogReadMessage,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogReadMessageCopyWith<$Res> get data {
  
  return $LogReadMessageCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogAddReaction extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogAddReaction({required this.data}): super._();
  

@override final  LogAddReaction data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogAddReactionCopyWith<UConvoGetLogLogsLogAddReaction> get copyWith => _$UConvoGetLogLogsLogAddReactionCopyWithImpl<UConvoGetLogLogsLogAddReaction>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogAddReaction&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logAddReaction(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogAddReactionCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogAddReactionCopyWith(UConvoGetLogLogsLogAddReaction value, $Res Function(UConvoGetLogLogsLogAddReaction) _then) = _$UConvoGetLogLogsLogAddReactionCopyWithImpl;
@useResult
$Res call({
 LogAddReaction data
});


$LogAddReactionCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogAddReactionCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogAddReactionCopyWith<$Res> {
  _$UConvoGetLogLogsLogAddReactionCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogAddReaction _self;
  final $Res Function(UConvoGetLogLogsLogAddReaction) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogAddReaction(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogAddReaction,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogAddReactionCopyWith<$Res> get data {
  
  return $LogAddReactionCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsLogRemoveReaction extends UConvoGetLogLogs {
  const UConvoGetLogLogsLogRemoveReaction({required this.data}): super._();
  

@override final  LogRemoveReaction data;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsLogRemoveReactionCopyWith<UConvoGetLogLogsLogRemoveReaction> get copyWith => _$UConvoGetLogLogsLogRemoveReactionCopyWithImpl<UConvoGetLogLogsLogRemoveReaction>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsLogRemoveReaction&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UConvoGetLogLogs.logRemoveReaction(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsLogRemoveReactionCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsLogRemoveReactionCopyWith(UConvoGetLogLogsLogRemoveReaction value, $Res Function(UConvoGetLogLogsLogRemoveReaction) _then) = _$UConvoGetLogLogsLogRemoveReactionCopyWithImpl;
@useResult
$Res call({
 LogRemoveReaction data
});


$LogRemoveReactionCopyWith<$Res> get data;

}
/// @nodoc
class _$UConvoGetLogLogsLogRemoveReactionCopyWithImpl<$Res>
    implements $UConvoGetLogLogsLogRemoveReactionCopyWith<$Res> {
  _$UConvoGetLogLogsLogRemoveReactionCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsLogRemoveReaction _self;
  final $Res Function(UConvoGetLogLogsLogRemoveReaction) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsLogRemoveReaction(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LogRemoveReaction,
  ));
}

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LogRemoveReactionCopyWith<$Res> get data {
  
  return $LogRemoveReactionCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UConvoGetLogLogsUnknown extends UConvoGetLogLogs {
  const UConvoGetLogLogsUnknown({required final  Map<String, dynamic> data}): _data = data,super._();
  

 final  Map<String, dynamic> _data;
@override Map<String, dynamic> get data {
  if (_data is EqualUnmodifiableMapView) return _data;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_data);
}


/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UConvoGetLogLogsUnknownCopyWith<UConvoGetLogLogsUnknown> get copyWith => _$UConvoGetLogLogsUnknownCopyWithImpl<UConvoGetLogLogsUnknown>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UConvoGetLogLogsUnknown&&const DeepCollectionEquality().equals(other._data, _data));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_data));

@override
String toString() {
  return 'UConvoGetLogLogs.unknown(data: $data)';
}


}

/// @nodoc
abstract mixin class $UConvoGetLogLogsUnknownCopyWith<$Res> implements $UConvoGetLogLogsCopyWith<$Res> {
  factory $UConvoGetLogLogsUnknownCopyWith(UConvoGetLogLogsUnknown value, $Res Function(UConvoGetLogLogsUnknown) _then) = _$UConvoGetLogLogsUnknownCopyWithImpl;
@useResult
$Res call({
 Map<String, dynamic> data
});




}
/// @nodoc
class _$UConvoGetLogLogsUnknownCopyWithImpl<$Res>
    implements $UConvoGetLogLogsUnknownCopyWith<$Res> {
  _$UConvoGetLogLogsUnknownCopyWithImpl(this._self, this._then);

  final UConvoGetLogLogsUnknown _self;
  final $Res Function(UConvoGetLogLogsUnknown) _then;

/// Create a copy of UConvoGetLogLogs
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UConvoGetLogLogsUnknown(
data: null == data ? _self._data : data // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>,
  ));
}


}

// dart format on
