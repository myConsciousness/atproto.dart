// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'union_view_record.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$UEmbedRecordViewRecord {

 Object get data;



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecord&&const DeepCollectionEquality().equals(other.data, data));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data));

@override
String toString() {
  return 'UEmbedRecordViewRecord(data: $data)';
}


}

/// @nodoc
class $UEmbedRecordViewRecordCopyWith<$Res>  {
$UEmbedRecordViewRecordCopyWith(UEmbedRecordViewRecord _, $Res Function(UEmbedRecordViewRecord) __);
}


/// Adds pattern-matching-related methods to [UEmbedRecordViewRecord].
extension UEmbedRecordViewRecordPatterns on UEmbedRecordViewRecord {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( UEmbedRecordViewRecordEmbedRecordViewRecord value)?  embedRecordViewRecord,TResult Function( UEmbedRecordViewRecordEmbedRecordViewNotFound value)?  embedRecordViewNotFound,TResult Function( UEmbedRecordViewRecordEmbedRecordViewBlocked value)?  embedRecordViewBlocked,TResult Function( UEmbedRecordViewRecordEmbedRecordViewDetached value)?  embedRecordViewDetached,TResult Function( UEmbedRecordViewRecordGeneratorView value)?  generatorView,TResult Function( UEmbedRecordViewRecordListView value)?  listView,TResult Function( UEmbedRecordViewRecordLabelerView value)?  labelerView,TResult Function( UEmbedRecordViewRecordStarterPackViewBasic value)?  starterPackViewBasic,TResult Function( UEmbedRecordViewRecordUnknown value)?  unknown,required TResult orElse(),}){
final _that = this;
switch (_that) {
case UEmbedRecordViewRecordEmbedRecordViewRecord() when embedRecordViewRecord != null:
return embedRecordViewRecord(_that);case UEmbedRecordViewRecordEmbedRecordViewNotFound() when embedRecordViewNotFound != null:
return embedRecordViewNotFound(_that);case UEmbedRecordViewRecordEmbedRecordViewBlocked() when embedRecordViewBlocked != null:
return embedRecordViewBlocked(_that);case UEmbedRecordViewRecordEmbedRecordViewDetached() when embedRecordViewDetached != null:
return embedRecordViewDetached(_that);case UEmbedRecordViewRecordGeneratorView() when generatorView != null:
return generatorView(_that);case UEmbedRecordViewRecordListView() when listView != null:
return listView(_that);case UEmbedRecordViewRecordLabelerView() when labelerView != null:
return labelerView(_that);case UEmbedRecordViewRecordStarterPackViewBasic() when starterPackViewBasic != null:
return starterPackViewBasic(_that);case UEmbedRecordViewRecordUnknown() when unknown != null:
return unknown(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( UEmbedRecordViewRecordEmbedRecordViewRecord value)  embedRecordViewRecord,required TResult Function( UEmbedRecordViewRecordEmbedRecordViewNotFound value)  embedRecordViewNotFound,required TResult Function( UEmbedRecordViewRecordEmbedRecordViewBlocked value)  embedRecordViewBlocked,required TResult Function( UEmbedRecordViewRecordEmbedRecordViewDetached value)  embedRecordViewDetached,required TResult Function( UEmbedRecordViewRecordGeneratorView value)  generatorView,required TResult Function( UEmbedRecordViewRecordListView value)  listView,required TResult Function( UEmbedRecordViewRecordLabelerView value)  labelerView,required TResult Function( UEmbedRecordViewRecordStarterPackViewBasic value)  starterPackViewBasic,required TResult Function( UEmbedRecordViewRecordUnknown value)  unknown,}){
final _that = this;
switch (_that) {
case UEmbedRecordViewRecordEmbedRecordViewRecord():
return embedRecordViewRecord(_that);case UEmbedRecordViewRecordEmbedRecordViewNotFound():
return embedRecordViewNotFound(_that);case UEmbedRecordViewRecordEmbedRecordViewBlocked():
return embedRecordViewBlocked(_that);case UEmbedRecordViewRecordEmbedRecordViewDetached():
return embedRecordViewDetached(_that);case UEmbedRecordViewRecordGeneratorView():
return generatorView(_that);case UEmbedRecordViewRecordListView():
return listView(_that);case UEmbedRecordViewRecordLabelerView():
return labelerView(_that);case UEmbedRecordViewRecordStarterPackViewBasic():
return starterPackViewBasic(_that);case UEmbedRecordViewRecordUnknown():
return unknown(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( UEmbedRecordViewRecordEmbedRecordViewRecord value)?  embedRecordViewRecord,TResult? Function( UEmbedRecordViewRecordEmbedRecordViewNotFound value)?  embedRecordViewNotFound,TResult? Function( UEmbedRecordViewRecordEmbedRecordViewBlocked value)?  embedRecordViewBlocked,TResult? Function( UEmbedRecordViewRecordEmbedRecordViewDetached value)?  embedRecordViewDetached,TResult? Function( UEmbedRecordViewRecordGeneratorView value)?  generatorView,TResult? Function( UEmbedRecordViewRecordListView value)?  listView,TResult? Function( UEmbedRecordViewRecordLabelerView value)?  labelerView,TResult? Function( UEmbedRecordViewRecordStarterPackViewBasic value)?  starterPackViewBasic,TResult? Function( UEmbedRecordViewRecordUnknown value)?  unknown,}){
final _that = this;
switch (_that) {
case UEmbedRecordViewRecordEmbedRecordViewRecord() when embedRecordViewRecord != null:
return embedRecordViewRecord(_that);case UEmbedRecordViewRecordEmbedRecordViewNotFound() when embedRecordViewNotFound != null:
return embedRecordViewNotFound(_that);case UEmbedRecordViewRecordEmbedRecordViewBlocked() when embedRecordViewBlocked != null:
return embedRecordViewBlocked(_that);case UEmbedRecordViewRecordEmbedRecordViewDetached() when embedRecordViewDetached != null:
return embedRecordViewDetached(_that);case UEmbedRecordViewRecordGeneratorView() when generatorView != null:
return generatorView(_that);case UEmbedRecordViewRecordListView() when listView != null:
return listView(_that);case UEmbedRecordViewRecordLabelerView() when labelerView != null:
return labelerView(_that);case UEmbedRecordViewRecordStarterPackViewBasic() when starterPackViewBasic != null:
return starterPackViewBasic(_that);case UEmbedRecordViewRecordUnknown() when unknown != null:
return unknown(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function( EmbedRecordViewRecord data)?  embedRecordViewRecord,TResult Function( EmbedRecordViewNotFound data)?  embedRecordViewNotFound,TResult Function( EmbedRecordViewBlocked data)?  embedRecordViewBlocked,TResult Function( EmbedRecordViewDetached data)?  embedRecordViewDetached,TResult Function( GeneratorView data)?  generatorView,TResult Function( ListView data)?  listView,TResult Function( LabelerView data)?  labelerView,TResult Function( StarterPackViewBasic data)?  starterPackViewBasic,TResult Function( Map<String, dynamic> data)?  unknown,required TResult orElse(),}) {final _that = this;
switch (_that) {
case UEmbedRecordViewRecordEmbedRecordViewRecord() when embedRecordViewRecord != null:
return embedRecordViewRecord(_that.data);case UEmbedRecordViewRecordEmbedRecordViewNotFound() when embedRecordViewNotFound != null:
return embedRecordViewNotFound(_that.data);case UEmbedRecordViewRecordEmbedRecordViewBlocked() when embedRecordViewBlocked != null:
return embedRecordViewBlocked(_that.data);case UEmbedRecordViewRecordEmbedRecordViewDetached() when embedRecordViewDetached != null:
return embedRecordViewDetached(_that.data);case UEmbedRecordViewRecordGeneratorView() when generatorView != null:
return generatorView(_that.data);case UEmbedRecordViewRecordListView() when listView != null:
return listView(_that.data);case UEmbedRecordViewRecordLabelerView() when labelerView != null:
return labelerView(_that.data);case UEmbedRecordViewRecordStarterPackViewBasic() when starterPackViewBasic != null:
return starterPackViewBasic(_that.data);case UEmbedRecordViewRecordUnknown() when unknown != null:
return unknown(_that.data);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function( EmbedRecordViewRecord data)  embedRecordViewRecord,required TResult Function( EmbedRecordViewNotFound data)  embedRecordViewNotFound,required TResult Function( EmbedRecordViewBlocked data)  embedRecordViewBlocked,required TResult Function( EmbedRecordViewDetached data)  embedRecordViewDetached,required TResult Function( GeneratorView data)  generatorView,required TResult Function( ListView data)  listView,required TResult Function( LabelerView data)  labelerView,required TResult Function( StarterPackViewBasic data)  starterPackViewBasic,required TResult Function( Map<String, dynamic> data)  unknown,}) {final _that = this;
switch (_that) {
case UEmbedRecordViewRecordEmbedRecordViewRecord():
return embedRecordViewRecord(_that.data);case UEmbedRecordViewRecordEmbedRecordViewNotFound():
return embedRecordViewNotFound(_that.data);case UEmbedRecordViewRecordEmbedRecordViewBlocked():
return embedRecordViewBlocked(_that.data);case UEmbedRecordViewRecordEmbedRecordViewDetached():
return embedRecordViewDetached(_that.data);case UEmbedRecordViewRecordGeneratorView():
return generatorView(_that.data);case UEmbedRecordViewRecordListView():
return listView(_that.data);case UEmbedRecordViewRecordLabelerView():
return labelerView(_that.data);case UEmbedRecordViewRecordStarterPackViewBasic():
return starterPackViewBasic(_that.data);case UEmbedRecordViewRecordUnknown():
return unknown(_that.data);}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function( EmbedRecordViewRecord data)?  embedRecordViewRecord,TResult? Function( EmbedRecordViewNotFound data)?  embedRecordViewNotFound,TResult? Function( EmbedRecordViewBlocked data)?  embedRecordViewBlocked,TResult? Function( EmbedRecordViewDetached data)?  embedRecordViewDetached,TResult? Function( GeneratorView data)?  generatorView,TResult? Function( ListView data)?  listView,TResult? Function( LabelerView data)?  labelerView,TResult? Function( StarterPackViewBasic data)?  starterPackViewBasic,TResult? Function( Map<String, dynamic> data)?  unknown,}) {final _that = this;
switch (_that) {
case UEmbedRecordViewRecordEmbedRecordViewRecord() when embedRecordViewRecord != null:
return embedRecordViewRecord(_that.data);case UEmbedRecordViewRecordEmbedRecordViewNotFound() when embedRecordViewNotFound != null:
return embedRecordViewNotFound(_that.data);case UEmbedRecordViewRecordEmbedRecordViewBlocked() when embedRecordViewBlocked != null:
return embedRecordViewBlocked(_that.data);case UEmbedRecordViewRecordEmbedRecordViewDetached() when embedRecordViewDetached != null:
return embedRecordViewDetached(_that.data);case UEmbedRecordViewRecordGeneratorView() when generatorView != null:
return generatorView(_that.data);case UEmbedRecordViewRecordListView() when listView != null:
return listView(_that.data);case UEmbedRecordViewRecordLabelerView() when labelerView != null:
return labelerView(_that.data);case UEmbedRecordViewRecordStarterPackViewBasic() when starterPackViewBasic != null:
return starterPackViewBasic(_that.data);case UEmbedRecordViewRecordUnknown() when unknown != null:
return unknown(_that.data);case _:
  return null;

}
}

}

/// @nodoc


class UEmbedRecordViewRecordEmbedRecordViewRecord extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordEmbedRecordViewRecord({required this.data}): super._();
  

@override final  EmbedRecordViewRecord data;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWith<UEmbedRecordViewRecordEmbedRecordViewRecord> get copyWith => _$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWithImpl<UEmbedRecordViewRecordEmbedRecordViewRecord>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordEmbedRecordViewRecord&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UEmbedRecordViewRecord.embedRecordViewRecord(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordEmbedRecordViewRecordCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordEmbedRecordViewRecordCopyWith(UEmbedRecordViewRecordEmbedRecordViewRecord value, $Res Function(UEmbedRecordViewRecordEmbedRecordViewRecord) _then) = _$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWithImpl;
@useResult
$Res call({
 EmbedRecordViewRecord data
});


$EmbedRecordViewRecordCopyWith<$Res> get data;

}
/// @nodoc
class _$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordEmbedRecordViewRecordCopyWith<$Res> {
  _$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordEmbedRecordViewRecord _self;
  final $Res Function(UEmbedRecordViewRecordEmbedRecordViewRecord) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordEmbedRecordViewRecord(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as EmbedRecordViewRecord,
  ));
}

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$EmbedRecordViewRecordCopyWith<$Res> get data {
  
  return $EmbedRecordViewRecordCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UEmbedRecordViewRecordEmbedRecordViewNotFound extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordEmbedRecordViewNotFound({required this.data}): super._();
  

@override final  EmbedRecordViewNotFound data;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWith<UEmbedRecordViewRecordEmbedRecordViewNotFound> get copyWith => _$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWithImpl<UEmbedRecordViewRecordEmbedRecordViewNotFound>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordEmbedRecordViewNotFound&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UEmbedRecordViewRecord.embedRecordViewNotFound(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWith(UEmbedRecordViewRecordEmbedRecordViewNotFound value, $Res Function(UEmbedRecordViewRecordEmbedRecordViewNotFound) _then) = _$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWithImpl;
@useResult
$Res call({
 EmbedRecordViewNotFound data
});


$EmbedRecordViewNotFoundCopyWith<$Res> get data;

}
/// @nodoc
class _$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWith<$Res> {
  _$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordEmbedRecordViewNotFound _self;
  final $Res Function(UEmbedRecordViewRecordEmbedRecordViewNotFound) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordEmbedRecordViewNotFound(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as EmbedRecordViewNotFound,
  ));
}

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$EmbedRecordViewNotFoundCopyWith<$Res> get data {
  
  return $EmbedRecordViewNotFoundCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UEmbedRecordViewRecordEmbedRecordViewBlocked extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordEmbedRecordViewBlocked({required this.data}): super._();
  

@override final  EmbedRecordViewBlocked data;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWith<UEmbedRecordViewRecordEmbedRecordViewBlocked> get copyWith => _$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWithImpl<UEmbedRecordViewRecordEmbedRecordViewBlocked>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordEmbedRecordViewBlocked&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UEmbedRecordViewRecord.embedRecordViewBlocked(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWith(UEmbedRecordViewRecordEmbedRecordViewBlocked value, $Res Function(UEmbedRecordViewRecordEmbedRecordViewBlocked) _then) = _$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWithImpl;
@useResult
$Res call({
 EmbedRecordViewBlocked data
});


$EmbedRecordViewBlockedCopyWith<$Res> get data;

}
/// @nodoc
class _$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWith<$Res> {
  _$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordEmbedRecordViewBlocked _self;
  final $Res Function(UEmbedRecordViewRecordEmbedRecordViewBlocked) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordEmbedRecordViewBlocked(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as EmbedRecordViewBlocked,
  ));
}

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$EmbedRecordViewBlockedCopyWith<$Res> get data {
  
  return $EmbedRecordViewBlockedCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UEmbedRecordViewRecordEmbedRecordViewDetached extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordEmbedRecordViewDetached({required this.data}): super._();
  

@override final  EmbedRecordViewDetached data;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWith<UEmbedRecordViewRecordEmbedRecordViewDetached> get copyWith => _$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWithImpl<UEmbedRecordViewRecordEmbedRecordViewDetached>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordEmbedRecordViewDetached&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UEmbedRecordViewRecord.embedRecordViewDetached(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWith(UEmbedRecordViewRecordEmbedRecordViewDetached value, $Res Function(UEmbedRecordViewRecordEmbedRecordViewDetached) _then) = _$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWithImpl;
@useResult
$Res call({
 EmbedRecordViewDetached data
});


$EmbedRecordViewDetachedCopyWith<$Res> get data;

}
/// @nodoc
class _$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWith<$Res> {
  _$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordEmbedRecordViewDetached _self;
  final $Res Function(UEmbedRecordViewRecordEmbedRecordViewDetached) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordEmbedRecordViewDetached(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as EmbedRecordViewDetached,
  ));
}

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$EmbedRecordViewDetachedCopyWith<$Res> get data {
  
  return $EmbedRecordViewDetachedCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UEmbedRecordViewRecordGeneratorView extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordGeneratorView({required this.data}): super._();
  

@override final  GeneratorView data;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordGeneratorViewCopyWith<UEmbedRecordViewRecordGeneratorView> get copyWith => _$UEmbedRecordViewRecordGeneratorViewCopyWithImpl<UEmbedRecordViewRecordGeneratorView>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordGeneratorView&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UEmbedRecordViewRecord.generatorView(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordGeneratorViewCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordGeneratorViewCopyWith(UEmbedRecordViewRecordGeneratorView value, $Res Function(UEmbedRecordViewRecordGeneratorView) _then) = _$UEmbedRecordViewRecordGeneratorViewCopyWithImpl;
@useResult
$Res call({
 GeneratorView data
});


$GeneratorViewCopyWith<$Res> get data;

}
/// @nodoc
class _$UEmbedRecordViewRecordGeneratorViewCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordGeneratorViewCopyWith<$Res> {
  _$UEmbedRecordViewRecordGeneratorViewCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordGeneratorView _self;
  final $Res Function(UEmbedRecordViewRecordGeneratorView) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordGeneratorView(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as GeneratorView,
  ));
}

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$GeneratorViewCopyWith<$Res> get data {
  
  return $GeneratorViewCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UEmbedRecordViewRecordListView extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordListView({required this.data}): super._();
  

@override final  ListView data;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordListViewCopyWith<UEmbedRecordViewRecordListView> get copyWith => _$UEmbedRecordViewRecordListViewCopyWithImpl<UEmbedRecordViewRecordListView>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordListView&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UEmbedRecordViewRecord.listView(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordListViewCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordListViewCopyWith(UEmbedRecordViewRecordListView value, $Res Function(UEmbedRecordViewRecordListView) _then) = _$UEmbedRecordViewRecordListViewCopyWithImpl;
@useResult
$Res call({
 ListView data
});


$ListViewCopyWith<$Res> get data;

}
/// @nodoc
class _$UEmbedRecordViewRecordListViewCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordListViewCopyWith<$Res> {
  _$UEmbedRecordViewRecordListViewCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordListView _self;
  final $Res Function(UEmbedRecordViewRecordListView) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordListView(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as ListView,
  ));
}

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ListViewCopyWith<$Res> get data {
  
  return $ListViewCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UEmbedRecordViewRecordLabelerView extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordLabelerView({required this.data}): super._();
  

@override final  LabelerView data;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordLabelerViewCopyWith<UEmbedRecordViewRecordLabelerView> get copyWith => _$UEmbedRecordViewRecordLabelerViewCopyWithImpl<UEmbedRecordViewRecordLabelerView>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordLabelerView&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UEmbedRecordViewRecord.labelerView(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordLabelerViewCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordLabelerViewCopyWith(UEmbedRecordViewRecordLabelerView value, $Res Function(UEmbedRecordViewRecordLabelerView) _then) = _$UEmbedRecordViewRecordLabelerViewCopyWithImpl;
@useResult
$Res call({
 LabelerView data
});


$LabelerViewCopyWith<$Res> get data;

}
/// @nodoc
class _$UEmbedRecordViewRecordLabelerViewCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordLabelerViewCopyWith<$Res> {
  _$UEmbedRecordViewRecordLabelerViewCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordLabelerView _self;
  final $Res Function(UEmbedRecordViewRecordLabelerView) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordLabelerView(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LabelerView,
  ));
}

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LabelerViewCopyWith<$Res> get data {
  
  return $LabelerViewCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UEmbedRecordViewRecordStarterPackViewBasic extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordStarterPackViewBasic({required this.data}): super._();
  

@override final  StarterPackViewBasic data;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordStarterPackViewBasicCopyWith<UEmbedRecordViewRecordStarterPackViewBasic> get copyWith => _$UEmbedRecordViewRecordStarterPackViewBasicCopyWithImpl<UEmbedRecordViewRecordStarterPackViewBasic>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordStarterPackViewBasic&&(identical(other.data, data) || other.data == data));
}


@override
int get hashCode => Object.hash(runtimeType,data);

@override
String toString() {
  return 'UEmbedRecordViewRecord.starterPackViewBasic(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordStarterPackViewBasicCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordStarterPackViewBasicCopyWith(UEmbedRecordViewRecordStarterPackViewBasic value, $Res Function(UEmbedRecordViewRecordStarterPackViewBasic) _then) = _$UEmbedRecordViewRecordStarterPackViewBasicCopyWithImpl;
@useResult
$Res call({
 StarterPackViewBasic data
});


$StarterPackViewBasicCopyWith<$Res> get data;

}
/// @nodoc
class _$UEmbedRecordViewRecordStarterPackViewBasicCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordStarterPackViewBasicCopyWith<$Res> {
  _$UEmbedRecordViewRecordStarterPackViewBasicCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordStarterPackViewBasic _self;
  final $Res Function(UEmbedRecordViewRecordStarterPackViewBasic) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordStarterPackViewBasic(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as StarterPackViewBasic,
  ));
}

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$StarterPackViewBasicCopyWith<$Res> get data {
  
  return $StarterPackViewBasicCopyWith<$Res>(_self.data, (value) {
    return _then(_self.copyWith(data: value));
  });
}
}

/// @nodoc


class UEmbedRecordViewRecordUnknown extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordUnknown({required final  Map<String, dynamic> data}): _data = data,super._();
  

 final  Map<String, dynamic> _data;
@override Map<String, dynamic> get data {
  if (_data is EqualUnmodifiableMapView) return _data;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_data);
}


/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UEmbedRecordViewRecordUnknownCopyWith<UEmbedRecordViewRecordUnknown> get copyWith => _$UEmbedRecordViewRecordUnknownCopyWithImpl<UEmbedRecordViewRecordUnknown>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UEmbedRecordViewRecordUnknown&&const DeepCollectionEquality().equals(other._data, _data));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_data));

@override
String toString() {
  return 'UEmbedRecordViewRecord.unknown(data: $data)';
}


}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordUnknownCopyWith<$Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordUnknownCopyWith(UEmbedRecordViewRecordUnknown value, $Res Function(UEmbedRecordViewRecordUnknown) _then) = _$UEmbedRecordViewRecordUnknownCopyWithImpl;
@useResult
$Res call({
 Map<String, dynamic> data
});




}
/// @nodoc
class _$UEmbedRecordViewRecordUnknownCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordUnknownCopyWith<$Res> {
  _$UEmbedRecordViewRecordUnknownCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordUnknown _self;
  final $Res Function(UEmbedRecordViewRecordUnknown) _then;

/// Create a copy of UEmbedRecordViewRecord
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(UEmbedRecordViewRecordUnknown(
data: null == data ? _self._data : data // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>,
  ));
}


}

// dart format on
