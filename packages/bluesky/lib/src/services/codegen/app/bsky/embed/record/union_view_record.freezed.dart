// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'union_view_record.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UEmbedRecordViewRecord {
  Object get data;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecord &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'UEmbedRecordViewRecord(data: $data)';
  }
}

/// @nodoc
class $UEmbedRecordViewRecordCopyWith<$Res> {
  $UEmbedRecordViewRecordCopyWith(
      UEmbedRecordViewRecord _, $Res Function(UEmbedRecordViewRecord) __);
}

/// Adds pattern-matching-related methods to [UEmbedRecordViewRecord].
extension UEmbedRecordViewRecordPatterns on UEmbedRecordViewRecord {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UEmbedRecordViewRecordEmbedRecordViewRecord value)?
        embedRecordViewRecord,
    TResult Function(UEmbedRecordViewRecordEmbedRecordViewNotFound value)?
        embedRecordViewNotFound,
    TResult Function(UEmbedRecordViewRecordEmbedRecordViewBlocked value)?
        embedRecordViewBlocked,
    TResult Function(UEmbedRecordViewRecordEmbedRecordViewDetached value)?
        embedRecordViewDetached,
    TResult Function(UEmbedRecordViewRecordGeneratorView value)? generatorView,
    TResult Function(UEmbedRecordViewRecordListView value)? listView,
    TResult Function(UEmbedRecordViewRecordLabelerView value)? labelerView,
    TResult Function(UEmbedRecordViewRecordStarterPackViewBasic value)?
        starterPackViewBasic,
    TResult Function(UEmbedRecordViewRecordUnknown value)? unknown,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case UEmbedRecordViewRecordEmbedRecordViewRecord()
          when embedRecordViewRecord != null:
        return embedRecordViewRecord(_that);
      case UEmbedRecordViewRecordEmbedRecordViewNotFound()
          when embedRecordViewNotFound != null:
        return embedRecordViewNotFound(_that);
      case UEmbedRecordViewRecordEmbedRecordViewBlocked()
          when embedRecordViewBlocked != null:
        return embedRecordViewBlocked(_that);
      case UEmbedRecordViewRecordEmbedRecordViewDetached()
          when embedRecordViewDetached != null:
        return embedRecordViewDetached(_that);
      case UEmbedRecordViewRecordGeneratorView() when generatorView != null:
        return generatorView(_that);
      case UEmbedRecordViewRecordListView() when listView != null:
        return listView(_that);
      case UEmbedRecordViewRecordLabelerView() when labelerView != null:
        return labelerView(_that);
      case UEmbedRecordViewRecordStarterPackViewBasic()
          when starterPackViewBasic != null:
        return starterPackViewBasic(_that);
      case UEmbedRecordViewRecordUnknown() when unknown != null:
        return unknown(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UEmbedRecordViewRecordEmbedRecordViewRecord value)
        embedRecordViewRecord,
    required TResult Function(
            UEmbedRecordViewRecordEmbedRecordViewNotFound value)
        embedRecordViewNotFound,
    required TResult Function(
            UEmbedRecordViewRecordEmbedRecordViewBlocked value)
        embedRecordViewBlocked,
    required TResult Function(
            UEmbedRecordViewRecordEmbedRecordViewDetached value)
        embedRecordViewDetached,
    required TResult Function(UEmbedRecordViewRecordGeneratorView value)
        generatorView,
    required TResult Function(UEmbedRecordViewRecordListView value) listView,
    required TResult Function(UEmbedRecordViewRecordLabelerView value)
        labelerView,
    required TResult Function(UEmbedRecordViewRecordStarterPackViewBasic value)
        starterPackViewBasic,
    required TResult Function(UEmbedRecordViewRecordUnknown value) unknown,
  }) {
    final _that = this;
    switch (_that) {
      case UEmbedRecordViewRecordEmbedRecordViewRecord():
        return embedRecordViewRecord(_that);
      case UEmbedRecordViewRecordEmbedRecordViewNotFound():
        return embedRecordViewNotFound(_that);
      case UEmbedRecordViewRecordEmbedRecordViewBlocked():
        return embedRecordViewBlocked(_that);
      case UEmbedRecordViewRecordEmbedRecordViewDetached():
        return embedRecordViewDetached(_that);
      case UEmbedRecordViewRecordGeneratorView():
        return generatorView(_that);
      case UEmbedRecordViewRecordListView():
        return listView(_that);
      case UEmbedRecordViewRecordLabelerView():
        return labelerView(_that);
      case UEmbedRecordViewRecordStarterPackViewBasic():
        return starterPackViewBasic(_that);
      case UEmbedRecordViewRecordUnknown():
        return unknown(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UEmbedRecordViewRecordEmbedRecordViewRecord value)?
        embedRecordViewRecord,
    TResult? Function(UEmbedRecordViewRecordEmbedRecordViewNotFound value)?
        embedRecordViewNotFound,
    TResult? Function(UEmbedRecordViewRecordEmbedRecordViewBlocked value)?
        embedRecordViewBlocked,
    TResult? Function(UEmbedRecordViewRecordEmbedRecordViewDetached value)?
        embedRecordViewDetached,
    TResult? Function(UEmbedRecordViewRecordGeneratorView value)? generatorView,
    TResult? Function(UEmbedRecordViewRecordListView value)? listView,
    TResult? Function(UEmbedRecordViewRecordLabelerView value)? labelerView,
    TResult? Function(UEmbedRecordViewRecordStarterPackViewBasic value)?
        starterPackViewBasic,
    TResult? Function(UEmbedRecordViewRecordUnknown value)? unknown,
  }) {
    final _that = this;
    switch (_that) {
      case UEmbedRecordViewRecordEmbedRecordViewRecord()
          when embedRecordViewRecord != null:
        return embedRecordViewRecord(_that);
      case UEmbedRecordViewRecordEmbedRecordViewNotFound()
          when embedRecordViewNotFound != null:
        return embedRecordViewNotFound(_that);
      case UEmbedRecordViewRecordEmbedRecordViewBlocked()
          when embedRecordViewBlocked != null:
        return embedRecordViewBlocked(_that);
      case UEmbedRecordViewRecordEmbedRecordViewDetached()
          when embedRecordViewDetached != null:
        return embedRecordViewDetached(_that);
      case UEmbedRecordViewRecordGeneratorView() when generatorView != null:
        return generatorView(_that);
      case UEmbedRecordViewRecordListView() when listView != null:
        return listView(_that);
      case UEmbedRecordViewRecordLabelerView() when labelerView != null:
        return labelerView(_that);
      case UEmbedRecordViewRecordStarterPackViewBasic()
          when starterPackViewBasic != null:
        return starterPackViewBasic(_that);
      case UEmbedRecordViewRecordUnknown() when unknown != null:
        return unknown(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(EmbedRecordViewRecord data)? embedRecordViewRecord,
    TResult Function(EmbedRecordViewNotFound data)? embedRecordViewNotFound,
    TResult Function(EmbedRecordViewBlocked data)? embedRecordViewBlocked,
    TResult Function(EmbedRecordViewDetached data)? embedRecordViewDetached,
    TResult Function(GeneratorView data)? generatorView,
    TResult Function(ListView data)? listView,
    TResult Function(LabelerView data)? labelerView,
    TResult Function(StarterPackViewBasic data)? starterPackViewBasic,
    TResult Function(Map<String, dynamic> data)? unknown,
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case UEmbedRecordViewRecordEmbedRecordViewRecord()
          when embedRecordViewRecord != null:
        return embedRecordViewRecord(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewNotFound()
          when embedRecordViewNotFound != null:
        return embedRecordViewNotFound(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewBlocked()
          when embedRecordViewBlocked != null:
        return embedRecordViewBlocked(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewDetached()
          when embedRecordViewDetached != null:
        return embedRecordViewDetached(_that.data);
      case UEmbedRecordViewRecordGeneratorView() when generatorView != null:
        return generatorView(_that.data);
      case UEmbedRecordViewRecordListView() when listView != null:
        return listView(_that.data);
      case UEmbedRecordViewRecordLabelerView() when labelerView != null:
        return labelerView(_that.data);
      case UEmbedRecordViewRecordStarterPackViewBasic()
          when starterPackViewBasic != null:
        return starterPackViewBasic(_that.data);
      case UEmbedRecordViewRecordUnknown() when unknown != null:
        return unknown(_that.data);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(EmbedRecordViewRecord data) embedRecordViewRecord,
    required TResult Function(EmbedRecordViewNotFound data)
        embedRecordViewNotFound,
    required TResult Function(EmbedRecordViewBlocked data)
        embedRecordViewBlocked,
    required TResult Function(EmbedRecordViewDetached data)
        embedRecordViewDetached,
    required TResult Function(GeneratorView data) generatorView,
    required TResult Function(ListView data) listView,
    required TResult Function(LabelerView data) labelerView,
    required TResult Function(StarterPackViewBasic data) starterPackViewBasic,
    required TResult Function(Map<String, dynamic> data) unknown,
  }) {
    final _that = this;
    switch (_that) {
      case UEmbedRecordViewRecordEmbedRecordViewRecord():
        return embedRecordViewRecord(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewNotFound():
        return embedRecordViewNotFound(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewBlocked():
        return embedRecordViewBlocked(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewDetached():
        return embedRecordViewDetached(_that.data);
      case UEmbedRecordViewRecordGeneratorView():
        return generatorView(_that.data);
      case UEmbedRecordViewRecordListView():
        return listView(_that.data);
      case UEmbedRecordViewRecordLabelerView():
        return labelerView(_that.data);
      case UEmbedRecordViewRecordStarterPackViewBasic():
        return starterPackViewBasic(_that.data);
      case UEmbedRecordViewRecordUnknown():
        return unknown(_that.data);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(EmbedRecordViewRecord data)? embedRecordViewRecord,
    TResult? Function(EmbedRecordViewNotFound data)? embedRecordViewNotFound,
    TResult? Function(EmbedRecordViewBlocked data)? embedRecordViewBlocked,
    TResult? Function(EmbedRecordViewDetached data)? embedRecordViewDetached,
    TResult? Function(GeneratorView data)? generatorView,
    TResult? Function(ListView data)? listView,
    TResult? Function(LabelerView data)? labelerView,
    TResult? Function(StarterPackViewBasic data)? starterPackViewBasic,
    TResult? Function(Map<String, dynamic> data)? unknown,
  }) {
    final _that = this;
    switch (_that) {
      case UEmbedRecordViewRecordEmbedRecordViewRecord()
          when embedRecordViewRecord != null:
        return embedRecordViewRecord(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewNotFound()
          when embedRecordViewNotFound != null:
        return embedRecordViewNotFound(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewBlocked()
          when embedRecordViewBlocked != null:
        return embedRecordViewBlocked(_that.data);
      case UEmbedRecordViewRecordEmbedRecordViewDetached()
          when embedRecordViewDetached != null:
        return embedRecordViewDetached(_that.data);
      case UEmbedRecordViewRecordGeneratorView() when generatorView != null:
        return generatorView(_that.data);
      case UEmbedRecordViewRecordListView() when listView != null:
        return listView(_that.data);
      case UEmbedRecordViewRecordLabelerView() when labelerView != null:
        return labelerView(_that.data);
      case UEmbedRecordViewRecordStarterPackViewBasic()
          when starterPackViewBasic != null:
        return starterPackViewBasic(_that.data);
      case UEmbedRecordViewRecordUnknown() when unknown != null:
        return unknown(_that.data);
      case _:
        return null;
    }
  }
}

/// @nodoc

class UEmbedRecordViewRecordEmbedRecordViewRecord
    extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordEmbedRecordViewRecord({required this.data})
      : super._();

  @override
  final EmbedRecordViewRecord data;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordEmbedRecordViewRecordCopyWith<
          UEmbedRecordViewRecordEmbedRecordViewRecord>
      get copyWith => _$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWithImpl<
          UEmbedRecordViewRecordEmbedRecordViewRecord>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordEmbedRecordViewRecord &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.embedRecordViewRecord(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordEmbedRecordViewRecordCopyWith<$Res>
    implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordEmbedRecordViewRecordCopyWith(
          UEmbedRecordViewRecordEmbedRecordViewRecord value,
          $Res Function(UEmbedRecordViewRecordEmbedRecordViewRecord) _then) =
      _$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWithImpl;
  @useResult
  $Res call({EmbedRecordViewRecord data});

  $EmbedRecordViewRecordCopyWith<$Res> get data;
}

/// @nodoc
class _$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordEmbedRecordViewRecordCopyWith<$Res> {
  _$UEmbedRecordViewRecordEmbedRecordViewRecordCopyWithImpl(
      this._self, this._then);

  final UEmbedRecordViewRecordEmbedRecordViewRecord _self;
  final $Res Function(UEmbedRecordViewRecordEmbedRecordViewRecord) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordEmbedRecordViewRecord(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as EmbedRecordViewRecord,
    ));
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbedRecordViewRecordCopyWith<$Res> get data {
    return $EmbedRecordViewRecordCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UEmbedRecordViewRecordEmbedRecordViewNotFound
    extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordEmbedRecordViewNotFound({required this.data})
      : super._();

  @override
  final EmbedRecordViewNotFound data;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWith<
          UEmbedRecordViewRecordEmbedRecordViewNotFound>
      get copyWith =>
          _$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWithImpl<
              UEmbedRecordViewRecordEmbedRecordViewNotFound>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordEmbedRecordViewNotFound &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.embedRecordViewNotFound(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWith<
    $Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWith(
          UEmbedRecordViewRecordEmbedRecordViewNotFound value,
          $Res Function(UEmbedRecordViewRecordEmbedRecordViewNotFound) _then) =
      _$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWithImpl;
  @useResult
  $Res call({EmbedRecordViewNotFound data});

  $EmbedRecordViewNotFoundCopyWith<$Res> get data;
}

/// @nodoc
class _$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWith<$Res> {
  _$UEmbedRecordViewRecordEmbedRecordViewNotFoundCopyWithImpl(
      this._self, this._then);

  final UEmbedRecordViewRecordEmbedRecordViewNotFound _self;
  final $Res Function(UEmbedRecordViewRecordEmbedRecordViewNotFound) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordEmbedRecordViewNotFound(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as EmbedRecordViewNotFound,
    ));
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbedRecordViewNotFoundCopyWith<$Res> get data {
    return $EmbedRecordViewNotFoundCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UEmbedRecordViewRecordEmbedRecordViewBlocked
    extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordEmbedRecordViewBlocked({required this.data})
      : super._();

  @override
  final EmbedRecordViewBlocked data;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWith<
          UEmbedRecordViewRecordEmbedRecordViewBlocked>
      get copyWith =>
          _$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWithImpl<
              UEmbedRecordViewRecordEmbedRecordViewBlocked>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordEmbedRecordViewBlocked &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.embedRecordViewBlocked(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWith<$Res>
    implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWith(
          UEmbedRecordViewRecordEmbedRecordViewBlocked value,
          $Res Function(UEmbedRecordViewRecordEmbedRecordViewBlocked) _then) =
      _$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWithImpl;
  @useResult
  $Res call({EmbedRecordViewBlocked data});

  $EmbedRecordViewBlockedCopyWith<$Res> get data;
}

/// @nodoc
class _$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWith<$Res> {
  _$UEmbedRecordViewRecordEmbedRecordViewBlockedCopyWithImpl(
      this._self, this._then);

  final UEmbedRecordViewRecordEmbedRecordViewBlocked _self;
  final $Res Function(UEmbedRecordViewRecordEmbedRecordViewBlocked) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordEmbedRecordViewBlocked(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as EmbedRecordViewBlocked,
    ));
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbedRecordViewBlockedCopyWith<$Res> get data {
    return $EmbedRecordViewBlockedCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UEmbedRecordViewRecordEmbedRecordViewDetached
    extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordEmbedRecordViewDetached({required this.data})
      : super._();

  @override
  final EmbedRecordViewDetached data;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWith<
          UEmbedRecordViewRecordEmbedRecordViewDetached>
      get copyWith =>
          _$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWithImpl<
              UEmbedRecordViewRecordEmbedRecordViewDetached>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordEmbedRecordViewDetached &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.embedRecordViewDetached(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWith<
    $Res> implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWith(
          UEmbedRecordViewRecordEmbedRecordViewDetached value,
          $Res Function(UEmbedRecordViewRecordEmbedRecordViewDetached) _then) =
      _$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWithImpl;
  @useResult
  $Res call({EmbedRecordViewDetached data});

  $EmbedRecordViewDetachedCopyWith<$Res> get data;
}

/// @nodoc
class _$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWith<$Res> {
  _$UEmbedRecordViewRecordEmbedRecordViewDetachedCopyWithImpl(
      this._self, this._then);

  final UEmbedRecordViewRecordEmbedRecordViewDetached _self;
  final $Res Function(UEmbedRecordViewRecordEmbedRecordViewDetached) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordEmbedRecordViewDetached(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as EmbedRecordViewDetached,
    ));
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EmbedRecordViewDetachedCopyWith<$Res> get data {
    return $EmbedRecordViewDetachedCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UEmbedRecordViewRecordGeneratorView extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordGeneratorView({required this.data}) : super._();

  @override
  final GeneratorView data;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordGeneratorViewCopyWith<
          UEmbedRecordViewRecordGeneratorView>
      get copyWith => _$UEmbedRecordViewRecordGeneratorViewCopyWithImpl<
          UEmbedRecordViewRecordGeneratorView>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordGeneratorView &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.generatorView(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordGeneratorViewCopyWith<$Res>
    implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordGeneratorViewCopyWith(
          UEmbedRecordViewRecordGeneratorView value,
          $Res Function(UEmbedRecordViewRecordGeneratorView) _then) =
      _$UEmbedRecordViewRecordGeneratorViewCopyWithImpl;
  @useResult
  $Res call({GeneratorView data});

  $GeneratorViewCopyWith<$Res> get data;
}

/// @nodoc
class _$UEmbedRecordViewRecordGeneratorViewCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordGeneratorViewCopyWith<$Res> {
  _$UEmbedRecordViewRecordGeneratorViewCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordGeneratorView _self;
  final $Res Function(UEmbedRecordViewRecordGeneratorView) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordGeneratorView(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as GeneratorView,
    ));
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GeneratorViewCopyWith<$Res> get data {
    return $GeneratorViewCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UEmbedRecordViewRecordListView extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordListView({required this.data}) : super._();

  @override
  final ListView data;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordListViewCopyWith<UEmbedRecordViewRecordListView>
      get copyWith => _$UEmbedRecordViewRecordListViewCopyWithImpl<
          UEmbedRecordViewRecordListView>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordListView &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.listView(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordListViewCopyWith<$Res>
    implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordListViewCopyWith(
          UEmbedRecordViewRecordListView value,
          $Res Function(UEmbedRecordViewRecordListView) _then) =
      _$UEmbedRecordViewRecordListViewCopyWithImpl;
  @useResult
  $Res call({ListView data});

  $ListViewCopyWith<$Res> get data;
}

/// @nodoc
class _$UEmbedRecordViewRecordListViewCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordListViewCopyWith<$Res> {
  _$UEmbedRecordViewRecordListViewCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordListView _self;
  final $Res Function(UEmbedRecordViewRecordListView) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordListView(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as ListView,
    ));
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ListViewCopyWith<$Res> get data {
    return $ListViewCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UEmbedRecordViewRecordLabelerView extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordLabelerView({required this.data}) : super._();

  @override
  final LabelerView data;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordLabelerViewCopyWith<UEmbedRecordViewRecordLabelerView>
      get copyWith => _$UEmbedRecordViewRecordLabelerViewCopyWithImpl<
          UEmbedRecordViewRecordLabelerView>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordLabelerView &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.labelerView(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordLabelerViewCopyWith<$Res>
    implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordLabelerViewCopyWith(
          UEmbedRecordViewRecordLabelerView value,
          $Res Function(UEmbedRecordViewRecordLabelerView) _then) =
      _$UEmbedRecordViewRecordLabelerViewCopyWithImpl;
  @useResult
  $Res call({LabelerView data});

  $LabelerViewCopyWith<$Res> get data;
}

/// @nodoc
class _$UEmbedRecordViewRecordLabelerViewCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordLabelerViewCopyWith<$Res> {
  _$UEmbedRecordViewRecordLabelerViewCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordLabelerView _self;
  final $Res Function(UEmbedRecordViewRecordLabelerView) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordLabelerView(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as LabelerView,
    ));
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LabelerViewCopyWith<$Res> get data {
    return $LabelerViewCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UEmbedRecordViewRecordStarterPackViewBasic
    extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordStarterPackViewBasic({required this.data})
      : super._();

  @override
  final StarterPackViewBasic data;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordStarterPackViewBasicCopyWith<
          UEmbedRecordViewRecordStarterPackViewBasic>
      get copyWith => _$UEmbedRecordViewRecordStarterPackViewBasicCopyWithImpl<
          UEmbedRecordViewRecordStarterPackViewBasic>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordStarterPackViewBasic &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.starterPackViewBasic(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordStarterPackViewBasicCopyWith<$Res>
    implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordStarterPackViewBasicCopyWith(
          UEmbedRecordViewRecordStarterPackViewBasic value,
          $Res Function(UEmbedRecordViewRecordStarterPackViewBasic) _then) =
      _$UEmbedRecordViewRecordStarterPackViewBasicCopyWithImpl;
  @useResult
  $Res call({StarterPackViewBasic data});

  $StarterPackViewBasicCopyWith<$Res> get data;
}

/// @nodoc
class _$UEmbedRecordViewRecordStarterPackViewBasicCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordStarterPackViewBasicCopyWith<$Res> {
  _$UEmbedRecordViewRecordStarterPackViewBasicCopyWithImpl(
      this._self, this._then);

  final UEmbedRecordViewRecordStarterPackViewBasic _self;
  final $Res Function(UEmbedRecordViewRecordStarterPackViewBasic) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordStarterPackViewBasic(
      data: null == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as StarterPackViewBasic,
    ));
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $StarterPackViewBasicCopyWith<$Res> get data {
    return $StarterPackViewBasicCopyWith<$Res>(_self.data, (value) {
      return _then(_self.copyWith(data: value));
    });
  }
}

/// @nodoc

class UEmbedRecordViewRecordUnknown extends UEmbedRecordViewRecord {
  const UEmbedRecordViewRecordUnknown(
      {required final Map<String, dynamic> data})
      : _data = data,
        super._();

  final Map<String, dynamic> _data;
  @override
  Map<String, dynamic> get data {
    if (_data is EqualUnmodifiableMapView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_data);
  }

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UEmbedRecordViewRecordUnknownCopyWith<UEmbedRecordViewRecordUnknown>
      get copyWith => _$UEmbedRecordViewRecordUnknownCopyWithImpl<
          UEmbedRecordViewRecordUnknown>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UEmbedRecordViewRecordUnknown &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));

  @override
  String toString() {
    return 'UEmbedRecordViewRecord.unknown(data: $data)';
  }
}

/// @nodoc
abstract mixin class $UEmbedRecordViewRecordUnknownCopyWith<$Res>
    implements $UEmbedRecordViewRecordCopyWith<$Res> {
  factory $UEmbedRecordViewRecordUnknownCopyWith(
          UEmbedRecordViewRecordUnknown value,
          $Res Function(UEmbedRecordViewRecordUnknown) _then) =
      _$UEmbedRecordViewRecordUnknownCopyWithImpl;
  @useResult
  $Res call({Map<String, dynamic> data});
}

/// @nodoc
class _$UEmbedRecordViewRecordUnknownCopyWithImpl<$Res>
    implements $UEmbedRecordViewRecordUnknownCopyWith<$Res> {
  _$UEmbedRecordViewRecordUnknownCopyWithImpl(this._self, this._then);

  final UEmbedRecordViewRecordUnknown _self;
  final $Res Function(UEmbedRecordViewRecordUnknown) _then;

  /// Create a copy of UEmbedRecordViewRecord
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  $Res call({
    Object? data = null,
  }) {
    return _then(UEmbedRecordViewRecordUnknown(
      data: null == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

// dart format on
